# Reflection: Game of Life – AI-Assisted Development

## 🧰 Tools Used

During this project, I used three main AI-assisted tools:

1. **ChatGPT** – for understanding the assignment, refining prompts, and general guidance.
2. **Lovable** – to quickly generate a fully functional frontend UI using a single well-crafted prompt.
3. **Cursor** – to analyze and improve the code generated by Lovable, refactor the architecture, fix bugs, and implement the bonus feature (saving/restoring board state).

## 💬 Prompting Strategy

### ✔️ Effective Prompts:
- A well-structured initial prompt to **Lovable** resulted in a complete and clean scaffold with all the required features in just one iteration.
- Prompts crafted with the help of **ChatGPT** significantly improved my ability to get better results from both Lovable and Cursor.

### ❌ Less Effective Prompts:
- A prompt to **Cursor** asking it to "improve the architecture" caused it to restructure major parts of the code and unintentionally broke existing functionality.  
  **Lesson learned:** When requesting large-scale changes, it's important to explicitly tell the AI to **preserve current functionality**.

## 🧠 Tool Evaluation

| Tool     | Strengths                                         | Weaknesses                        |
|----------|---------------------------------------------------|-----------------------------------|
| ChatGPT  | Excellent for understanding, prompting strategy   | Not used for direct code writing  |
| Lovable  | Created clean and responsive UI in one iteration  | Limited flexibility for edits     |
| Cursor   | Helped refactor, debug, and understand structure  | Overwrites logic if not guided    |

### Key Takeaways:
- Before asking AI tools to perform major modifications, **explicitly instruct them to maintain functionality**.
- AI tools can be incredibly helpful but must be guided carefully to avoid unexpected rewrites.

### Iteration Counts:
- **ChatGPT** – ~2–3 prompts (mainly for strategic planning)
- **Lovable** – Just **1** prompt (very successful)
- **Cursor** – ~10–15 iterations (debugging, refactoring, understanding structure)

## 🧹 Code Quality & Architecture

### ✔️ MVC Structure:

- **Model**:  
  - `gameLogic.ts`: Contains functions like `getNextGeneration`, `createEmptyGrid`, etc.
  - `useGameOfLife` hook: Maintains game state and core logic like `evolve`, `toggleCell`, etc.

- **View**:  
  - React components: `GameOfLife`, `GameGrid`, `GameControls`, `PatternLibrary`.

- **Controller**:  
  - `useGameOfLife` also acts as the controller, exposing actions and reacting to UI events.
  - Event handlers that connect user actions (button clicks, sliders) to the game logic.

### 🔧 Problem Solved:
- There was an initial **disconnect between the backend logic and the frontend interaction layer**.
- Using **Cursor** helped me cleanly bridge that gap and align the UI behavior with the internal game state.

---
